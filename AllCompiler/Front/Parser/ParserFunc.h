#ifndef PARSER_FUNC_H
#define PARSER_FUNC_H

#include "ParserType.h"
#include "ErrorType.h"


// ---------------------------------------------------------------------------------------------------
#define SYNTAX_ERROR(__context__, __number_error__)     \
    do {                                                \
        parserError (__number_error__, __context__);    \
        EXIT_FUNC ("Syntax Error", PARSER_SYNTAX_ERROR);\
    } while (0)
// ---------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------
/**
 @brief Функция создания связей в массиве узлов
 @param [in] start_node Начальный узел массива
 @param [in] amount Количество элементов в массива узлов
 @param [in] global_node Корень всего дерева
 @param [in] name_file Файл с кодом
*/
Status_t parserGlobal (Node_t* start_node,
                       size_t amount,
                       Node_t* global_node,
                       const char* name_file);
// ---------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------
/**
 @brief Функция считывания блока коды
 @param [in] inf Указатель на структуру с текущим положением
 @param [in] node Указатель на родителя поддерева
 @return PARSER_THIS_OK - если все нормально и это нужное место
         PARSER_NOT_THIS - если это не то место
         PARSER_ERROR - если произошла ошибка
*/
Status_t parserUnion (ParserContextInf_t* inf,
                      Node_t* node);
// ---------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------
/**
 @brief Функция считывания оператора с условием (if elif else while)
 @param [in] inf Указатель на структуру с текущим положением
 @param [in] node Указатель на родителя поддерева
 @return PARSER_THIS_OK - если все нормально и это нужное место
         PARSER_NOT_THIS - если это не то место
         PARSER_ERROR - если произошла ошибка
*/
Status_t parserCondOper (ParserContextInf_t* inf,
                         Node_t* node);
// ---------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------
/**
 @brief Функция считывания приравнивания
 @param [in] inf Указатель на структуру с текущим положением
 @param [in] node Указатель на родителя поддерева
 @return PARSER_THIS_OK - если все нормально и это нужное место
         PARSER_NOT_THIS - если это не то место
         PARSER_ERROR - если произошла ошибка
*/
Status_t parserAssign (ParserContextInf_t* inf,
                       Node_t* node);
// ---------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------
/**
 * \brief Функция считывания ключевого слова return
 * \param [in] inf Указатель на структуру с текущим положением
 * \param [in] parent Указатель на родителя поддерева
 * \return  PARSER_THIS_OK - если все нормально и это нужное место
            PARSER_NOT_THIS - если это не то место
            PARSER_ERROR - если произошла ошибка
*/
Status_t parserReturn (ParserContextInf_t* inf,
                       Node_t* node);
// ---------------------------------------------------------------------------------------------------



// ---------------------------------------------------------------------------------------------------
/**
 @brief Функция считывания объявления функции
 @param [in] inf Указатель на структуру с текущим положением
 @param [in] node Указатель на родителя поддерева
 @return PARSER_THIS_OK - если все нормально и это нужное место
         PARSER_NOT_THIS - если это не то место
         PARSER_ERROR - если произошла ошибка
*/
Status_t parserDeclarationFunc (ParserContextInf_t* inf,
                                Node_t* parent);
// ---------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------
/**
 @brief Функция считывания объявления переменной
 @param [in] inf Указатель на структуру с текущим положением
 @param [in] parent Указатель на родителя поддерева
 @return PARSER_THIS_OK - если все нормально и это нужное место
         PARSER_NOT_THIS - если это не то место
         PARSER_ERROR - если произошла ошибка
*/
Status_t parserDeclarationVar (ParserContextInf_t* inf,
                               Node_t* parent);
// ---------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------
/**
 @brief Функция считывания выражения AddSub [+ '<>=' AddSub]
 @param [in] inf Указатель на структуру с текущим положением
 @param [in] node Указатель на родителя поддерева
 @return PARSER_THIS_OK - если все нормально и это нужное место
         PARSER_NOT_THIS - если это не то место
         PARSER_ERROR - если произошла ошибка
*/
Status_t parserExpresion (ParserContextInf_t* inf,
                          Node_t* node);
// ---------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------
/**
 @brief Функция считывания суммирования MulDiv
 @param [in] inf Указатель на структуру с текущим положением
 @param [in] node Указатель на родителя поддерева
 @return PARSER_THIS_OK - если все нормально и это нужное место
         PARSER_NOT_THIS - если это не то место
         PARSER_ERROR - если произошла ошибка
*/
Status_t parserAddSub (ParserContextInf_t* inf,
                       Node_t* node);
// ---------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------
/**
 @brief Функция считывания умножения Power
 @param [in] inf Указатель на структуру с текущим положением
 @param [in] node Указатель на родителя поддерева
 @return PARSER_THIS_OK - если все нормально и это нужное место
         PARSER_NOT_THIS - если это не то место
         PARSER_ERROR - если произошла ошибка
*/
Status_t parserMulDiv (ParserContextInf_t* inf,
                       Node_t* node);
// ---------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------
/**
 @brief Функция считывания значения
 @param [in] inf Указатель на структуру с текущим положением
 @param [in] node Указатель на родителя поддерева
 @return PARSER_THIS_OK - если все нормально и это нужное место
         PARSER_NOT_THIS - если это не то место
         PARSER_ERROR - если произошла ошибка
*/
Status_t parserValue (ParserContextInf_t* inf,
                      Node_t* node);
// ---------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------
/**
 @brief Функция считывания идентификатора
 @param [in] inf Указатель на структуру с текущим положением
 @param [in] node Указатель на родителя поддерева
 @return PARSER_THIS_OK - если все нормально и это нужное место
         PARSER_NOT_THIS - если это не то место
         PARSER_ERROR - если произошла ошибка
*/
Status_t parserIndent (ParserContextInf_t* inf,
                       Node_t* parent);
// ---------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------
/**
 * \brief Функция считывания вызова функции
 * \param [in] inf Указатель на структуру с текущим положением
 * \param [in] parent Указатель на родителя поддерева
 * \return  PARSER_THIS_OK - если все нормально и это нужное место
            PARSER_NOT_THIS - если это не то место
            PARSER_ERROR - если произошла ошибка
*/
Status_t parserCallFunc (ParserContextInf_t* inf,
                         Node_t* parent);
// ---------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------
/**
 * \brief Функция считывания переменной
 * \param [in] inf Указатель на структуру с текущим положением
 * \param [in] parent Указатель на родителя поддерева
 * \return  PARSER_THIS_OK - если все нормально и это нужное место
            PARSER_NOT_THIS - если это не то место
            PARSER_ERROR - если произошла ошибка
*/
Status_t parserVar (ParserContextInf_t* inf,
                    Node_t* parent);
// ---------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------
/**
 @brief Функция считывания числа
 @param [in] inf Указатель на структуру с текущим положением
 @param [in] node Указатель на родителя поддерева
 @return PARSER_THIS_OK - если все нормально и это нужное место
         PARSER_NOT_THIS - если это не то место
         PARSER_ERROR - если произошла ошибка
*/
Status_t parserNumber (ParserContextInf_t* inf,
                       Node_t* parent);
// ---------------------------------------------------------------------------------------------------


// ---------------------------------------------------------------------------------------------------
#define isComma(__node__)       checkPunctNode (__node__, PUNCT_COMMA)
#define isLeftRound(__node__)   checkPunctNode (__node__, PUNCT_LEFT_ROUND)
#define isRightRound(__node__)  checkPunctNode (__node__, PUNCT_RIGHT_ROUND)
#define isLeftTang(__node__)    checkPunctNode (__node__, PUNCT_LEFT_TANG)
#define isRightTang(__node__)   checkPunctNode (__node__, PUNCT_RIGHT_TANG)
#define isEndChar(__node__)     checkPunctNode (__node__, PUNCT_END_STR)
// ---------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------
/**
 * \brief Функция проверки узла на соответствие с типом пунктуации и значением
 * \param [in] node Узел, который проверяют
 * \param [in] val ЗначениеЮ которое должно быть у узла
 * \return 1 - если совпадает, иначе 0
 */
int checkPunctNode (Node_t* node, int val);
// ---------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------
/**
 @brief Функция смены текущего узла в контексте
 @param [in] inf Указатель на структуру контекста
*/
int nextNode (ParserContextInf_t* inf);
// ---------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------
/**
 @brief Функция скипа всех '\n'
 @param [in] inf Указатель на структуру контекста
*/
int skipCharEnd (ParserContextInf_t* inf);
// ---------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------
/**
 * \brief Функция скипа всех символов переноса на новую строку '\'
 * \param [in] inf Указатель на структуру контекста
 */
int skipCharNext (ParserContextInf_t* inf);
// ---------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------
/**
 * \brief Функция пропуска всех разделяющий символов (\n и \)
 * \param [in] inf Указатель на структуру контекста
*/
int skipVoid (ParserContextInf_t* inf);
// ---------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------
/**
 @brief Функция выдачи следующего неконечного контекстного токена
 @param [in] inf Указатель на структуру контекста
 @return Узел
*/
Node_t* getNextNotEndNode (ParserContextInf_t* inf);
// ---------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------
/**
 @brief Функция вывода ошибки по её номеру
 @param [in] error Номер ошибки
 @param [in] inf Указатель на структуру контекста
*/
int parserError (ParserError_t error,
                 ParserContextInf_t* inf);
// ---------------------------------------------------------------------------------------------------


#endif /* PARSER_FUNC_H */
